Redis是完全开源免费的，遵守BSD协议，是一个高性能的Key-Value数据库。是Remote Dictionary Server远程字典服务器的简称。
Redis与其它的key-value缓存产品有以下三个特点：
1、Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。从这点来看，类似于持久化数据库。
2、Redis不仅仅支持简单的key-value类型的数据，同时还提供list、set、zset(sorted set)、hash等数据结构的存储。
3、支持数据备份，即master-slave模式的数据备份。

优势：
1、性能极高，读11w/s,写8.1w/s，因为Redis使用的是内存，而不是硬盘，但Redis可以持久化。
2、相比memcached，数据类型丰富。memcached只有key-value存储。
3、原子性，redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性操作。
4、丰富的特性，Redis还支持publish/subscribe，通知，key过期等特性。

与其它的key-value存储有什么不同？ // heheda

Redis配置

Redis 默认端口是6379
可通过CONFIG SET指令来修改配置，当然也可以直接修改安装目录下的redis.conf文件
例如：
CONFIG GET * 得到所有的配置项
CONFIG SET指令为CONFIG SET CONFIG_FIELD FIELD

Redis指令:Redis指令不区分大小写，但是key区分
Key - Value 类型 (String 类型)

SET KEY VALUE                                   eg SET USERNAME "YAMIKAZE"
GET KEY                                         eg GET USERNAME  --> "YAMIKAZE"
MGET/MSET 同时获取多个键值，用法与前面两个一致。
GETRANGE KEY START END                          eg GETRANGE USERNAME 2 5 ---> "MIKA"
GETSET KEY VALUE                                与SET KEY VALUE一致，只不过会返回KEY的旧值，没有旧值返回nil，类似于java的Map
APPEND KEY VALUE                                如果KEY存在，将VALUE加到KEY对应值的末尾
DECR KEY                                        将key所对应的值减1，如果key对应的value不存在，则将value初始化为0进行操作，如果value不是数字，则报错，可以是数字字符串
DECR KEY NUMBER                                 减少NUMBER
INCR KEY                                        与上一个指令刚好相反，值加1
INCR KEY NUMBER                                 增加NUMBER
INCRBYFLOAT KEY FLOAT                           增加相应浮点数
STRLEN KEY                                      返回KEY对应value的长度
KEY pattern                                     找出匹配pattern的所有键，不建议使用，这个指令需要遍历所有key
EXSIT key                                       key是否存在
DEL key1 key2                                   删除键，返回值是删除键的个数，没有键被删除时返回0
TYPE key                                        获得键对应的value的类型
GETBIT key index                                获取下标为index的key所对应value二进制的数字。index可以是0，如果index超出范围，获得0，如果index小于0报错
SETBIT key index 0/1                            与GETBIT相反，报错一样，如果设置的值不是0 或者 1 报错一样，如果设置的值不是0
BITCOUNT key                                    计算字节范围
BITOP OR/AND/XOR/NOT desKey key1 key2           对key1和key2进行异或与非操作，结果存储进desKey中

散列类型(hash):不支持数据类型嵌套，里面类型只能是String类型 对比java中的hashtable
HSET key field value                            eg、HSET car color red
HGET key field                                  eg、HGET car color
HMSET key field value [key value]               eg、HMSET car color "red" name "IBM" type "car"
HMGET key field field ...                       eg、HMGET car color type
HGETALL key                                     eg、HGETALL car //得到所有car的属性 包括field以及value
HEXISTS key field                               eg、HEXISTS car color //判断car是否有color属性
HSETNX key field value                          eg、HSETNX car color red //当car的color属性不存在时赋值
HINCRBY key field value                         //与String类型操作一致
HDEL key field value                            //删除键
HKEYS key                                       //只获取属性名，不获取属性
HVALS key                                       //与上条指令刚好相反
HLEN key                                        //获取字段数量

列表类型 (list) // 类似于 java的stack，但java中的stack是通过数组实现的，这儿的列表存储类似于LinkedList
LPUSH KEY list                                  创建一个列表，向其中放进值，key对应列表。从左边放值
RPUSH                                           右边放值
LPOP key                                        从左边弹出值 //这步操作类似于栈
RPOP key                                        从右边弹出值
LLEN key                                        获取元素个数
LRANGE key start end                            与String类型一致
LSET key index value                            把下标为index的元素改为value
LREM key count value                            删除前count个值为value的元素
                                                count > 0 左边删除，count < 0 从右边删除|count|个 count = 0删除所有值为value的元素
LINDEX key index                                返回index下标的元素 //index从0 开始
												//注意：这儿的list 我认为 类似于栈
												//lpush list abc acd amk avi //列表中放入了4个元素
												//最上层的元素 为avi  =  最左边的元素为avi，即执行lpop操作 得到的不是abc 而是 avi
                                                这个index与LRAM的count是一致的
LTRIM key start end                             删除指定范围之外的元素
LINSERT key BEFORE|AFTER pivot value            从左到右查找值为pivot的元素，根据前面的BEFORE|AFTER选择插入，before = 该元素的上方 after 下方
												例如：lpush list 1 2 3 4 5
												执行指令：linsert list before 2 10 --> (右边|栈底)1 2 10 3 4 5(左边|栈顶)
RPOPLPUSH sourceKey desKey                      将sourceKey中的元素转到desKey中去 //只能转一个元素。要想完整复制，必须执行该条命令sourceKey length次
// 相当于从sourceKey RPOP 然后LPUSH到desKey中去，完整复制后 sourceKey为空，而desKey 为 原来的元素 加上 sourceKey的元素

集合类型(set类型) 至多存储2的32次方-1个元素 // 对比java中的 Set
SADD key member1 member2 ...                    eg、SADD set1 1 2 3 4 5 6 7 8 9 //返回值为成功添加元素的个数
SREM key member1 member2 ...                    eg、SREM set1 1 2 3 10 // 删除set1中 1 2 3 10 ，返回值是删除成功的个数
SMEMBERS key                                    eg、SMEMBERS set1 获取set1中的所有元素
SISMEMBERS key MEMBER                           eg、判断元素是否在集合中// 在 就返回1，不在返回0
集合的运算：
SDIFF set1 set2                                 集合的差集 set1 - set2，指令支持传入多个键，eg SDIFF set1 set2 set3 //先计算set1 - set2 在将结果得到的集合计算set4 - set3
SINTER set1 set2                                集合的交集，同样支持传入多个参数 //这两个指令不会对原集合的元素照成影响
SUNION set1 set2                                集合的并集。支持传入多个集合
=============================================================================================
SCRAD set1                                      eg、SCRAD set1 获取集合set1中的元素个数
SDIFFSTORE desKey set1                          将集合的差集求得后放入desKey中 //如果desKey中有元素，desKey会被清空
SINTERSTORE | SUNIONSTORE 与 SDIFFSTRRE 用法一致
SRANDMEMBER set [count]                          //返回count个随机元素，如果count>集合中元素个数 则返回全部，否则返回|count| 个元素，count<0时获取的元素可能相同
SPOP set                                         随机弹出一个元素 //弹出元素后不再存在于集合中

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
有序集合 ZSET (sorted set) //ps：这两个单词怎么拼才会得到zset? zset按照分数从小到大排序
ZADD key point member [point member]...          eg、ZADD zset1 86 tom 76 peter //point可以是双精度
ZSCORE key member                                eg、获取元素的分数 ZSCORE zset1 tom
ZRANGE key start end [WITHSCORES]                eg、ZRANGE zset1 0 -1 WITHSCORES //输出从下标0到最后一个(-1表示最后一个)元素的属性和分数
                                                     //会按照分数从小到大排列，如果分数相同Redis会按照字典顺序排列，如果是中文字符，Redis排序取决于中文的编码方式
ZREVRANGE key start end [WITHSCORES]             与ZRANGE相反，按照从大大小//加上WITHSCORES 输出都为 属性1 分数1 属性2 分数2......的形式
ZRANGEBYSCORE key minScore maxScore [WITHSCORES] [LIMIT offset count] //从分数范围选取元素 后面的limit类似于sql的分页。//注意：这儿的minScore和maxScore是包含在内的。
																	//如果不想包含minScore或者maxScore可以将指令这样写：ZRANGEBYSCORE zset1 (80 (100 WITHSCORES //这样就不包含80和100，同时可以用-inf和+inf表示无穷小和无穷大
ZINCRBY key incrementCount member               eg、ZINCRBY zset1 100 tom 增加zset1中tomcat的分数100分，如果指定元素不存在，会创建元素并将元素分数赋为0再加上值。ps：好像没有减少操作。
ZCARD zset                                      获取指定集合的元素个数
ZCOUNT zset min max                             获取指定集合的分数在min-max之间的元素个数，这儿的min、max与ZRANGEBYSCORE一致
ZREM zset member1 member2                       删除多个元素
ZREMRANGEBYRANK  zset start end                 按照索引范围删除元素 ZREMRANGEBYRANK zset1 0 2 删除索引0-2的元素
ZREMRANGEBYSCORE zset min max                   按照分数范围删除元素

计算有序集合的并集
ZINTERSTORE desKey numbersKey [key..] zset... WIGHTS  AGGREGATE SUM|MIN|MAX 默认为SUM
                                              权重，计算时分数会乘以该集合的权重
计算有序集合的交集：ZUNIONSTORE,用法与ZINTERSTORE一致

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Redis 事务\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
事务的一致性：同一个事务的所有操作，要么全部成功，要么全部失败。
开启事务：MULTI
结束事务：EXEC //开启事务后输入命令不会执行，会将命令存储进一个队列中。此外还能保证执行一个事务中的命令时不被其他的命令插入
Redis的事务不支持回滚，滚！
WATCH 指令
     监控key，如果在事务开始前key的值发生了改变，那么事务就不会执行。但是事务的EXEC执行后会取消所有键的监控。也可以使用UNWATCH取消监控	

EXPIRE key seconds 设置key在seconds秒内有效，过后无效，将被删除。连续两次对一个键使用EXPIRE指令，前面设置的时间将被后面的覆盖，参数必须是整数。
TTL key            返回一个键还有多久被删除，返回剩余时间，如果返回-1 表示不会过期
PERSIST key        取消一个键的过期时间，出了这个指令。对键重新进行赋值也会取消键的过期时间。
                   如果WATCH指令监控一个被设置了时间的键，等时间过期后，并不算是对键进行了改变。

SORT指令：排序：可以是list、set、zset(对有序集合排序，是对有序集合的属性排序，而不是分数)
eg、SORT key BY 名字 DESC(倒序) LIMIT offset count，如果by后面没有参数，则Redis不会排序

pass
pass
pass

--------------------------------------------------------------
Redis持久化方式
AOF：默认情况下没有开启AOF方式，可通过配置文件中的appendonly no 将no改为yes就开启了
假设执行了 SET a 1
           SET a 2
		   SET a 3
		   GET a //AOF会将前三条命令写进AOF文件中。当达到一定条件时，AOF文件会重写
SAVE 保存数据备份
恢复数据只需要将SAVE产生的文件移动到Redis的安装目录启动就行了。
