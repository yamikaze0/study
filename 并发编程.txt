1、java多线程是否一定比单线程快？(并行串行)
   个人理解：当进行的任务比较小时，使用多线程无疑会多出一些对象以及上下文切换的开销，而现代JVM运行是非常快的，有可能你新对象产生完成，串行已经完成任务了。
   所以只有大的任务，或者比较一定要异步操作的任务是用多线程。
2、避免死锁的几个办法：
   a、避免一个线程同时获取多个锁。
   b、避免线程在一个锁内同时占用多个资源，尽量保证每个锁只占用一个资源
   c、尝试用Lock代替Synchronized
   d、对于数据库锁，加锁与解锁必须在同一个连接内，否则会出现解锁失败的情况
3、线程的速度还与硬件资源等相关：
   硬件资源比如带宽的上传下载速度，硬盘读写速度(瓶颈在建立连接)、cpu的处理速度(目前一般没有这个限制，电脑运行已经很快了)。
   软件资源比如数据库连接、Socket连接
4、如何解决3带来的限制
   硬件：多机协同工作
   软件资源：数据池

5、volatile在多处理器开发中保证了共享变量的可见性，是一个轻量级的synchronized。不会引起线程上下文切换和调度。
   volatile关键字修饰的变量
6、一个对象引用占4个字节。

7、synchronized：锁一定是对象，不能是基本类型
   对于普通同步方法，锁是当前实例对象
   对于静态同步方法，锁是当前类的Class对象
   对于同步代码块，  锁是括号里面的对象
   在JVM中是使用monitorenter指令与monitorexit指令实现的
   eg、synchronized(obj) { System.out.println("abc");} ----> monitorenter {//code} monitorexit
   当解析到monitorenter时会尝试获取monitor对象，即锁obj对象

   对象在内存中的存储布局可以分为3块区域：对象头、实例数据、对齐填充。
   对象头包括两部分信息(8字节)：第一部分存储对象自身运行的数据。例如：hashCode、GC年龄、锁状态标志，线程持有的锁、偏向线程id
                         大小在32和64为中分别为32bit和64bit，官方称之为Mark Word。
						 第二部分是类型指针：即对象指向它的类元数据的指针，JVM通过这个判断该对象是那个类的实例。如果是数组，还必须记录数组的长度。
						
   对齐填充：只是保证对象的起始地址是8的整数倍，也就是java对象大小必须是8的整数倍。
   在JDK6中锁一共有4种状态：无锁状态、偏向锁、轻量级锁、重量级锁，这几个锁会随着竞争状态升级，但是不能降级。目的是为了提高获得锁和释放锁的效率。

8、并发编程的问题：如何解决线程之间的通信以及线程之间的同步?:共享内存和消息传递。java采用的是共享内存模型。
   在共享内存模型中，开发人员必须显示指定方法互斥来达到同步
fc548f23da5a7a2608636645c636dd7e

java的阻塞队列 
java提供了7中阻塞队列：
ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列      单向 FIFO
LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列     单向
PriorityBlockingQueue：一个支持优先级拍寻的无界阻塞队列   单向
DelayQueue：一个使用优先级队列实现的无界阻塞队列          单向
SynchronousQueue：一个不存储元素的阻塞队列
LinkedTransferQueue：一个由链表结构组成的无界阻塞队列
LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列

DelayQueue：支持延时
要求：队列中的元素必须实现Delayed接口
      队列中的元素必须事先getDelay方法
	  继承Compareable接口实现compareTo方法
	  
SynchronousQueue是一个不存储元素的阻塞队列，每一个put操作必须等低啊一个take操作，否则不能继续添加元素

阻塞队列实现的原理：
如果队列是空的 消费者会一直等待，当生产者添加元素时，阻塞队列会通知消费者。采用的是观察者模式？

JDK5以前，旧内存模型允许对volatile关键字修饰的变量与普通变量冲排序，JSR-33(JSR Java Specification Requests java规范提案)
使得volatile的读写与锁的释放获取具有相同的内存语义。
增强final的内存语义：就内存模型中，多次读取同一个final的值可能会不一致，为此为final增加了两个重排序规则

java中的类分为5大类：
1、不可变对象，如String，不可变的类一定是线程安全的，每次操作都不会原对象做出改变，如split()、substring()方法都是返回一个新对象，如果对象中只有基本类型，将基本类型设置为final即是一个不可变的类，具体参考String类
2、线程绝对安全，任何场景，情况下，不需要额外做同步操作，返回的结果都是一致的。
3、线程相对安全，对单个对象调用其方法是安全的，但在多线程的环境下需要做些同步操作来保证多次调用的结果是一致的，如果Vector类，这个类的方法虽然都是使用synchronized修饰的，但是在多线程的环境下可能会出现ArrayIndexOfBoundException
4、线程兼容，java中的大多数类都是线程兼容的，即多线程情况下要做同步操作保证调用结果一致，同步操作参考上面
5、线程相对，没救了 做了同步操作也阻止不了，java类库基本没有这种类