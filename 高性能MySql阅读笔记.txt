MySql的逻辑架构：上下左右表示朝向哪边的箭头
---------------------------------
|  |--------------------------   |
|  |       连接/线程处理     |   |
|  |--------------------------   |
|       |下             |下      |
|  |----------      |---------|  |
|  |查询缓存 |--- 左|  解析器 |  |
|  |----------      |---------|  |
|                        | 下    |   
|  |---------------------------| |
|  |          优化器           | |
|  |---------------------------| |
|--------------------------------| 

||||||||||||存储引擎||||||||||||||
 
1、客户端：这层服务并不是Mysql独有的，这部分做的主要是连接处理，授权认证。
2、第二层：连接/线程处理、查询缓存、解析器。大多数Mysql的核心功能都在这一层，包括查询解析，分析、优化、缓存以及所有的内置函数。
           所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图。
3、第三层：存储引擎：负责Mysql数据的存储和提取。每个存储引擎都有优势与劣势，且存储引擎不会去解析SQL语句，不同的存储引擎之间也不会相互通信，而只是简单的响应上层服务器的请求。

连接管理与安全性：Q：既然每个连接都有一个线程，而线程会被缓存，意思就是线程与连接是非绑定的状态？
    每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。且服务器会负责缓存线程，因此不需要为每一个新建的连接创建或销毁线程。
	当客户端连接到Mysql服务器时，服务器需要对其进行认证，给予用户名、原始主机信息和密码。如果使用了SSL方式连接，还可以使用X.509方式验证。连接成功后，服务器会继续验证该客户端(该用户)是否具有执行某个特定查询的条件。

优化与执行：Mysql会解析查询、并创建内部数据结构(解析树)，然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响他的决策过程，也可以请求优化器解释优化过程的各个因素
		    优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。
			对于SELECT语句，在解析查询之前，服务器会先检查查询缓存，如果能在其中找到对应的查询，那么服务器就不必在执行查询解析、优化和执行整个过程。
			
并发控制：
        1、读写锁：当一个用户正在修改某一部分数据时，Mysql会通过锁定防止其他用户读取同一数据。大多数时候Mysql锁的内部管理都是透明的。
	     锁的粒度：表锁 与 行级锁，表锁在服务器层实现，而行级锁只在存储引擎层实现。

事务：一组原子性的SQL查询
    ACID：原子性(acomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)
	原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务的操作要么全部提交成功，要么全部失败回滚。
	一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
	隔离性：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。(可以自己打开两个Mysql的命令行，一个开启事务做操作但不提交，另一个在前一个操作后查询数据，看数据是否改变)
    持久性：一旦事务提交，其所做的修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。 
	
隔离级别：对应事务的隔离性。在Mysql中，定义了4中隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内与事务间是可见的，哪些是不可见的，较低级别的隔离通常可以执行更高的并发，系统的开销也更低。
         1、READ UNCOMMITED 未提交读。在这个级别中，即使没有commit，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。除非真的有非常必要的理由，不否不建议使用它。
		 2、READ COMMITED 提交读。大多数数据库系统默认的隔离级别都是这个，但Mysql不是。换句话说，一个事务在提交之前对其他事务都是不可见的。也叫不可重复读。因为执行两次同样的查询，可能会得到不一样的结果。
		 3、REPEATABLE READ 可重复读(Mysql默认级别)。解决了脏读的问题，保证了同一个事务中多次读取同样记录的结果是一致的。但是理论上，无法解决幻读的问题。
		                    幻读：当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时会产生幻行。InnoDB和XtraDB通过多版本并发控制解决了幻读的问题。
		 4、SERIALZABLE 可串行化：会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题.
        隔离级别         脏读可能性             不可重复读可能性      幻读可能性    加锁读
           1                 y                        y                   y            n
           2                 n                        y                   y            n
           3                 n                        n                   y            n
           4                 n                        n                   n            y
        Mysql通过SET TRANSACTION ISOLATION LEVEL 级别 来改变Mysql的级别。事务是由存储引擎实现的，且Mysql管理层不管理事务。		   
死锁：在数据库中死锁 产生有些是因为数据冲突，而有些是存储引擎的方式导致的。	Mysql加锁方式好像是表锁。

事务日志：
MMVC：Multiversion Concurrency Control 多版本并发控制。MMVC只在2、3两个隔离级别下进行
可以认为MMVC是行级锁的一个变种。在很多情况下避免了加锁操作，因此开销更低。写操作也只锁定必要的行。ps：好像是锁定整张表，这个只是解决幻读。

存储引擎：Mysql将每个数据库保存为数据目录下的一个子目录。其中表名.frm文件保存表的定义(包含使用引擎，创建时间，编码格式等等)，表名.idb保存数据
转换表的引擎：1、alter table tabel_name ENGINE = InnoDB; //这一种方式更换引擎会丢失原引擎的一些特性，而且比较耗时和耗资源
              2、将表使用mysqldump导出 然后修改create语句再导入 //这种记住导出文件含有DROP TABLE语句，记住删除。
			  3、结合了第一第二种方式：//推荐使用这一种方式
			                         a、先创建一个InnoDB引擎的表 cretae table tb_name like sourceTb //使用like 表名 会创建一个与source表结构一样的表
                                     b、将新创建表引擎改为innodb
                                     c、insert into tb_name select * from sourceTb 					//将source表中的数据复制到新创建的表中
									 